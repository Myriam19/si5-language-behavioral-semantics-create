/*
 * generated by Xtext 2.14.0
 */
package fr.unice.si5.polytech.serializer;

import com.google.inject.Inject;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.AbstractsyntaxPackage;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.Condition;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.CreateProgram;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.FiniteChoreography;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.GoForward;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.Instruction;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.Interruption;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.LoopChoreography;
import fr.unice.si5.polytech.createlanguage.abstractsyntax.ObjectFound;
import fr.unice.si5.polytech.services.CreateLanguageGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;

@SuppressWarnings("all")
public class CreateLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CreateLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AbstractsyntaxPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AbstractsyntaxPackage.CONDITION:
				sequence_Condition_Impl(context, (Condition) semanticObject); 
				return; 
			case AbstractsyntaxPackage.CREATE_PROGRAM:
				sequence_CreateProgram(context, (CreateProgram) semanticObject); 
				return; 
			case AbstractsyntaxPackage.FINITE_CHOREOGRAPHY:
				sequence_FiniteChoreography(context, (FiniteChoreography) semanticObject); 
				return; 
			case AbstractsyntaxPackage.GO_FORWARD:
				sequence_GoForward(context, (GoForward) semanticObject); 
				return; 
			case AbstractsyntaxPackage.INSTRUCTION:
				sequence_Instruction_Impl(context, (Instruction) semanticObject); 
				return; 
			case AbstractsyntaxPackage.INTERRUPTION:
				sequence_Interruption(context, (Interruption) semanticObject); 
				return; 
			case AbstractsyntaxPackage.LOOP_CHOREOGRAPHY:
				sequence_LoopChoreography(context, (LoopChoreography) semanticObject); 
				return; 
			case AbstractsyntaxPackage.OBJECT_FOUND:
				sequence_ObjectFound(context, (ObjectFound) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *     Condition_Impl returns Condition
	 *
	 * Constraint:
	 *     {Condition}
	 */
	protected void sequence_Condition_Impl(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreateProgram returns CreateProgram
	 *
	 * Constraint:
	 *     (name=EString (instructions+=Instruction instructions+=Instruction*)?)
	 */
	protected void sequence_CreateProgram(ISerializationContext context, CreateProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns FiniteChoreography
	 *     Choreography returns FiniteChoreography
	 *     FiniteChoreography returns FiniteChoreography
	 *
	 * Constraint:
	 *     (name=EString (interruptions+=Interruption interruptions+=Interruption*)? (instructions+=Instruction instructions+=Instruction*)?)
	 */
	protected void sequence_FiniteChoreography(ISerializationContext context, FiniteChoreography semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns GoForward
	 *     GoForward returns GoForward
	 *
	 * Constraint:
	 *     {GoForward}
	 */
	protected void sequence_GoForward(ISerializationContext context, GoForward semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Instruction
	 *     Instruction_Impl returns Instruction
	 *
	 * Constraint:
	 *     {Instruction}
	 */
	protected void sequence_Instruction_Impl(ISerializationContext context, Instruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Interruption returns Interruption
	 *
	 * Constraint:
	 *     (choreography=[Choreography|EString]? (conditions+=Condition conditions+=Condition*)?)
	 */
	protected void sequence_Interruption(ISerializationContext context, Interruption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns LoopChoreography
	 *     Choreography returns LoopChoreography
	 *     LoopChoreography returns LoopChoreography
	 *
	 * Constraint:
	 *     (name=EString (interruptions+=Interruption interruptions+=Interruption*)? (instructions+=Instruction instructions+=Instruction*)?)
	 */
	protected void sequence_LoopChoreography(ISerializationContext context, LoopChoreography semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns ObjectFound
	 *     ObjectFound returns ObjectFound
	 *
	 * Constraint:
	 *     {ObjectFound}
	 */
	protected void sequence_ObjectFound(ISerializationContext context, ObjectFound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
